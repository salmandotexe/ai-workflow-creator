from fastapi import APIRouter, Depends, HTTPException
from app.core.llm_client import LLMClient, get_llm_client
from app.tasks.workflow_tasks import execute_dynamic_workflow, celery_app
from app.schemas.models import UserInstruction, WorkflowDefinition
from celery.result import AsyncResult
import json

router = APIRouter()

@router.post("/generate-workflow/")
async def generate_and_execute_workflow(
    user_instruction: UserInstruction,
    llm_client: LLMClient = Depends(get_llm_client)
):
    instruction_text = user_instruction.model_dump().get("instruction")
    if not instruction_text:
        raise HTTPException(status_code=400, detail="Missing instruction text")

    workflow_json = llm_client.generate_workflow(instruction_text)
    try:
        workflow_steps = json.loads(workflow_json)
    except json.JSONDecodeError:
        raise HTTPException(status_code=500, detail="Invalid JSON generated by LLM")

    workflow_definition = {"workflow_name": "AI-Generated", "steps": workflow_steps}
    task = execute_dynamic_workflow.delay(workflow_definition)

    return {"task_id": task.id, "workflow": workflow_steps}


@router.post("/run-workflow/")
async def run_workflow(workflow_definition: WorkflowDefinition):
    if not workflow_definition.get("steps"):
        raise HTTPException(status_code=400, detail="Invalid Workflow Definition: Missing 'steps'")

    # Call the task with only the serializable dictionary.
    task = execute_dynamic_workflow.delay(workflow_definition.model_dump())
    
    return {"task_id": task.id, "status": "submitted"}

@router.get("/status/{task_id}")
async def get_workflow_status(task_id: str):
    """
    Retrieves the status of a Celery task.
    """
    task_result = AsyncResult(task_id, app=celery_app)

    if task_result.state == 'PENDING':
        # The task is waiting for execution or is in the queue.
        response = {"task_id": task_id, "status": "pending"}
    elif task_result.state == 'SUCCESS':
        # The task completed successfully.
        response = {"task_id": task_id, "status": "completed", "result": task_result.result}
    elif task_result.state == 'FAILURE':
        # The task failed.
        response = {
            "task_id": task_id, 
            "status": "failed", 
            # .info contains the exception, convert it to a string for JSON serialization.
            "error": str(task_result.info)
        }
    else:
        # For other states like 'STARTED', 'RETRY', etc.
        response = {"task_id": task_id, "status": task_result.state}
    
    return response