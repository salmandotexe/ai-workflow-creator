from fastapi import APIRouter, Depends, HTTPException
from app.core.llm_client import LLMClient, get_llm_client
from app.tasks.workflow_tasks import execute_dynamic_workflow
from app.services.storage_service import StorageService, get_storage_service
from celery.result import AsyncResult

import json

router = APIRouter()

@router.post("/generate-workflow/")
async def generate_and_execute_workflow(
    user_instruction: dict,
    openai_client: LLMClient = Depends(get_llm_client),
    storage_service: StorageService = Depends(get_storage_service)
):
    instruction_text = user_instruction.get("instruction")
    if not instruction_text:
        raise HTTPException(status_code=400, detail="Missing instruction text")

    workflow_json = openai_client.generate_workflow(instruction_text)
    try:
        workflow_steps = json.loads(workflow_json)
    except json.JSONDecodeError:
        raise HTTPException(status_code=500, detail="Invalid JSON generated by OpenAI")

    workflow_definition = {"workflow_name": "AI-Generated", "steps": workflow_steps}
    task = execute_dynamic_workflow.delay(workflow_definition, storage_service)

    return {"task_id": task.id, "workflow": workflow_steps}

@router.post("/run-workflow/")
async def run_workflow(workflow_definition: dict,
        storage_service: StorageService = Depends(get_storage_service)
    ):
    if not workflow_definition.get("steps"):
        raise HTTPException(status_code=400, detail="Invalid Workflow Definition")

    task = execute_dynamic_workflow.delay(workflow_definition, storage_service)
    return {"task_id": task.id, "status": "submitted"}

@router.get("/status/{task_id}")
async def get_workflow_status(task_id: str):
    task_result = AsyncResult(task_id)

    if task_result.state == 'PENDING':
        return {"task_id": task_id, "status": "pending"}
    elif task_result.state == 'SUCCESS':
        return {"task_id": task_id, "status": "completed", "result": task_result.result}
    elif task_result.state == 'FAILURE':
        return {"task_id": task_id, "status": "failed", "error": str(task_result.info)}
    else:
        return {"task_id": task_id, "status": task_result.state}
